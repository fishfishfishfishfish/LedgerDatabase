#include "distributed/mocks/strongstore/client.h"

using namespace std;

namespace mockstrongstore {

Client::Client()
{}

Client::Client(int timeout, const std::string& db_path)
{
    // Initialize all state here;
    client_id = 0;
    while (client_id == 0) {
        random_device rd;
        mt19937_64 gen(rd());
        uniform_int_distribution<uint64_t> dis;
        client_id = dis(gen);
    }
    t_id = (client_id/10000)*10000;

    // TODO: open a rocksdb with db_path
    store.reset(new letus::LETUS(timeout));
}

Client::~Client()
{}

/* Begins a transaction. All subsequent operations before a commit() or
 * abort() are part of this transaction.
 *
 * Return a TID for the transaction.
 */
void
Client::Begin()
{
    t_id++;
    participants.clear();
    commit_sleep = -1;

    // Initialize a transaction.
    txn = Transaction();
}

int Client::GetNVersions(const string& key, size_t n) {
    Promise promise(GET_TIMEOUT);

    history.emplace_back(std::make_pair(key, n));

    promise->Reply(REPLY_OK);
    return promise.GetReply();
}

int Client::Get(const string &key)
{
    Promise promise(GET_TIMEOUT);

    // Read your own writes, check the write set first.
    if (txn.getWriteSet().find(key) != txn.getWriteSet().end()) {
        promise->Reply(REPLY_OK);
        return;
    }

    if (txn.getReadSet().find(key) == txn.getReadSet().end()) {
        txn.addReadSet(key, Timestamp());
    }
    promise->Reply(REPLY_OK);
    return promise.GetReply();
}

int Client::BatchGet(std::map<std::string, std::string>& values, std::map<int,
    std::map<uint64_t, std::vector<std::string>>>& keys) {
  int status = REPLY_OK;
  // TODO
  return status;
}

int Client::BatchGet(std::map<std::string, std::string>& values) {
  int status = REPLY_OK;
  // TODO
  return status;
}

int Client::GetRange(const string& from, const string& to,
    std::map<std::string, std::string>& values, std::map<int,
    std::map<uint64_t, std::vector<std::string>>>& keys) {
  int status = REPLY_OK;
  // TODO
  return status;
}

void Client::BufferKey(const std::string& key) {
  // TODO
}

/* Sets the value corresponding to the supplied key. */
int
Client::Put(const string &key, const string &value)
{
    Promise promise(PUT_TIMEOUT);

    // Update the write set.
    txn.addWriteSet(key, value);
    promise->Reply(REPLY_OK);

    return promise.GetReply();
}

int
Client::Prepare(uint64_t &ts)
{
    int status;

    // 0. go get a timestamp for OCC

    // 1. Send commit-prepare to all shards.
    Promise promise(PUT_TIMEOUT);
    // TODO: send current transaction to the server
    // prepared[tid] = transaction
    promise.Reply(REPLY_OK, Timestamp(GetTime()));

    // 2. Wait for reply from all shards. (abort on timeout)
    status = promise->GetReply();
    ts = promise->GetTimestamp().getTimestamp();
    // TODO: If any shard returned false, abort the transaction.

    return status;
}

/* Attempts to commit the ongoing transaction. */
bool
Client::Commit()
{
    // Implementing 2 Phase Commit
    uint64_t ts = 0;
    int status;

    for (int i = 0; i < COMMIT_RETRIES; i++) {
        status = Prepare(ts);
        if (status == REPLY_OK || status == REPLY_FAIL) {
            break;
        }
    }

    if (status == REPLY_OK) {
      // TODO: Send commits
      // input: tid, timestamp
      proto::Reply reply;

      store.GetDigest(reply);
      std::vector<std::string> keys, vals;
      for (auto &read: txn.getReadSet()) {
        keys.push_back(read.first);
      }
      if (keys.size() > 0) {
        store.BatchGet(keys, reply);
        keys.clear();
      }

      if (history.size() > 0) {
        store.GetNVersions(history, reply);
      }

      for (auto &write : txn.getWriteSet()) {
        keys.push_back(write.first);
        vals.push_back(write.second);
      }
      if (keys.size() > 0) {
        store.put(keys, vals, Timestamp(ts), reply);
      }
      reply.set_status(0);
      return true;
    }

    // 4. If not, send abort to all shards.
    Abort();
    return false;
}

bool Client::Commit(std::map<int, std::map<uint64_t, std::vector<std::string>>>& keys) {
  /* keys: 2d mapping, (shard, block) -> key */
  // Implementing 2 Phase Commit
    uint64_t ts = 0;
    int status;

    for (int i = 0; i < COMMIT_RETRIES; i++) {
        status = Prepare(ts);
        if (status == REPLY_OK || status == REPLY_FAIL) {
            break;
        }
    }

    if (status == REPLY_OK) {
        // Send commits
        Promise promise(PREPARE_TIMEOUT);
        proto::Reply reply;

        store.GetDigest(reply);
        std::vector<std::string> keys, vals;
        for (auto &read: txn.getReadSet()) {
          keys.push_back(read.first);
        }
        if (keys.size() > 0) {
          store.BatchGet(keys, reply);
          keys.clear();
        }

        if (history.size() > 0) {
          store.GetNVersions(history, reply);
        }

        for (auto &write : txn.getWriteSet()) {
          keys.push_back(write.first);
          vals.push_back(write.second);
        }
        if (keys.size() > 0) {
          store.put(keys, vals, Timestamp(ts), reply);
        }
        reply.set_status(0);

        std::vector<uint64_t> estimate_blocks;
        std::vector<std::string> unverified_keys;
        VerifyStatus vs = VerifyStatus::UNVERIFIED;
        tip_block = reply.digest().block();
        for (size_t i = 0; i < reply.values_size(); ++i) {
          auto values = reply.values(i);
          unverified_keys.emplace_back(values.key());
          estimate_blocks.push_back(values.estimate_block());
        }
        promise->Reply(reply.status(), vs, unverified_keys, estimate_blocks);

        promise->GetReply();
        for (size_t i = 0; i < promise->EstimateBlockSize(); ++i) {
          auto block = promise->GetEstimateBlock(i);
          auto key = promise->GetUnverifiedKey(i);
          /* we only use one shard, shard = 0 */
          pair<int, Promise *> entry(0, promise);
          if (keys.find(entry.first) != keys.end()) {
            if (keys[entry.first].find(block) != keys[entry.first].end()) {
              keys[entry.first][block].emplace_back(key);
            } else {
              keys[entry.first].emplace(block, std::vector<std::string>{key});
            }
          } else {
            std::map<uint64_t, std::vector<std::string>> innermap; // map block -> keys
            innermap.emplace(block, std::vector<std::string>{key});
            keys.emplace(entry.first, innermap);
          }
        }
        return true;
    }

    // 4. If not, send abort to all shards.
    Abort();
    return false;
}

/* Aborts the ongoing transaction. */
void
Client::Abort()
{}

bool Client::Verify(std::map<int, std::map<uint64_t, std::vector<std::string>>>& keys) {
    // Contact the appropriate shard to set the value.
    bool is_successful = true;
    // TODO

    return is_successful;
}

bool Client::Audit(std::map<int, uint64_t>& seqs) {
    // Contact the appropriate shard to set the value.
    bool status = true;
    // TODO: audit
    return status;
}


/* Return statistics of most recent transaction. */
vector<int>
Client::Stats()
{
    vector<int> v;
    return v;
}


uint64_t
Client::GetTime()
{
    struct timeval now;
    uint64_t timestamp;

    gettimeofday(&now, NULL);

    now.tv_usec += simSkew;
    if (now.tv_usec > 999999) {
        now.tv_usec -= 1000000;
        now.tv_sec++;
    } else if (now.tv_usec < 0) {
        now.tv_usec += 1000000;
        now.tv_sec--;
    }

    timestamp = ((uint64_t)now.tv_sec << 32) | (uint64_t) (now.tv_usec);

    
    return timestamp;
}


} // namespace strongstore
